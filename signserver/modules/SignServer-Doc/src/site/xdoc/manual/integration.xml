<?xml version="1.0"?>
<!-- $Id$ -->
<document xmlns="http://maven.apache.org/XDOC/2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>SignServer Manual</title>
    </properties>

    <body title="Integration">
        
        <h1>Integration</h1>

        <macro name="toc">
            <param name="section" value="0"/>
            <param name="fromDepth" value="0"/>
            <param name="toDepth" value="4"/>
        </macro>

            <!--<p>
                TODO: Introduction
            </p>-->
            <section name="JavaDoc">
                    <p>
                            The JavaDoc for SignServer is available at SIGNSERVER_HOME/doc/api/index.html
                            after running "mvn javadoc:javadoc".    
                    </p>
		</section>

        <section name="Client Web Service">
            <p>
The SignServer ClientWS interface can be used to request signings from SignServer.
            </p>
            <p>
The WSDL file is located at the URL <code>http://&lt;hostname&gt;:8080/signserver/ClientWSService/ClientWS?wsdl</code> and locally in the sources under <code>modules/SignServer-Client-ClientWS/xml-resources/web-service-references/ClientWS/wsdl/localhost_8080/signserver/ClientWSService/ClientWS.wsdl</code>.
            </p>
            <subsection name="Operations">
                <table>
                    <!-- processData -->
                    <tr>
                        <td>
                            <p>
                                <b>
processData
                                </b>
                            </p>
                        </td>
                        <td>
                            <p>
Generic operation for request signing of any binary (or character) data.
                            </p>
                            <p>
Parameters:
                            </p>
                                <ul>
                                    <li>
<b>worker</b> (string)<br/>
Name of worker in SignServer which should handle the request.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Optional additional request data. For instance the PDFSigner accepts the PDF password as a request data.
                                    </li>
                                    <li>
<b>data</b> (base64Binary)<br/>
The document/data to process.
                                    </li>
                                </ul>
                            <p>
Output:
                            </p>
                                <ul>
                                    <li>
<b>archiveId</b> (string)
                                        <br/>
Identifier for the request if archiving was used.
                                    </li>
                                    <li>
<b>data</b> (base64Binary)<br/>
The signed binary/document.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Any optional additional response data.
                                    </li>
                                    <li>
<b>requestId</b> (integer)<br/>
Identifier for the request/response.
                                    </li>
                                    <li>
<b>signerCertificate</b> (base64Binary)<br/>
The signer certificate in binary format if available.
                                    </li>
                                </ul>
                            <p>
Faults:
                            </p>
                                <ul>
                                    <li>RequestFailedException</li>
                                    <li>InternalServerException</li>
                                </ul>
                        </td>
                    </tr>
                    
                    <!-- processSOD -->
                    <tr>
                        <td>
                            <p>
                                <b>
processSOD
                                </b>
                            </p>
                        </td>
                        <td>
                            <p>
Operation for requesting an SOD to be created and signed.<br/>
The ePassport production system calls this operation to get an SOD for the supplied data groups.
                            </p>
                            <p>
Parameters:
                            </p>
                                <ul>
                                    <li>
<b>worker</b> (string)<br/>
Name of worker in SignServer which should be used for constructing the SOD.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Optional additional request data. Not used.
                                    </li>
                                    <li>
<b>sodData</b> (a sodRequest structure)<br/>
The sodRequest should contain a sequence of datagroups (id 1-16 and their values),
optionally also the version of the LDS to use and the version of Unicode.
                                    </li>
                                </ul>
                            <p>
Output:
                            </p>
                                <ul>
                                    <li>
<b>archiveId</b> (string)
                                        <br/>
Identifier for the request if archiving was used.
                                    </li>
                                    <li>
<b>data</b> (base64Binary)<br/>
The SOD binary.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Any optional additional response data.
                                    </li>
                                    <li>
<b>requestId</b> (integer)<br/>
Identifier for the request/response.
                                    </li>
                                    <li>
<b>signerCertificate</b> (base64Binary)<br/>
The signer (DS) certificate in binary format if available.
                                    </li>
                                </ul>
                            <p>
Faults:
                            </p>
                                <ul>
                                    <li>RequestFailedException</li>
                                    <li>InternalServerException</li>
                                </ul>
                        </td>
                    </tr>
                    
                </table>
            </subsection>
        </section>
        
        <section name="The old Web Services interface" id="signserverws">
                <p>
The SignServerWS is the old web services interface now replaced by SignServer ClientWS. It was 
new to version 3.0 and at the time replaced the RMI-SSL interface from version 1.0 and 2.0 for two reasons, the RMI-SSL were based on a commercial library and it only worked for Java clients.
                    </p>
                    <p>
The SignServerWS WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/signserverws/signserverws?wsdl
                    </p>
                    <p>
The interface has two calls, the main one is 'process' which takes a collection of process request to a processable worker and returns a collection of process responses, the second one is getStatus that performs a health check of the node and returns an OK message if the node is healthy.
                    </p>
                    <p>
                        <b>Notice:</b>
All though the SignServerWS interface uses web services the actual process data is base64 encoded byte arrays in a special binary format. You will have to lookup the Java source code for the exact format of the request and response data. An alternative is to instead use the much simpler <a href="#Web Server Interface">Web Server Interface</a> or the newer <a href="#Client Web Service">ClientWS interface</a>. 
                    </p>
                    <p>
The getStatus call can be used to implement high-availability towards the client. The Java client API described in the next section have built in support for different high availability policies.
                    </p>
                    <p>
It's possible to turn off the WebService interface by disabling it in the build configuration.
                    </p>
                    <p>
This interface is only supported using HTTPS. The reason is that JBoss 4 does not rewrite the protocol part of the WSDL URL so we had to hard code it for it to work with HTTPS. For details about this see <a href="https://jira.primekey.se/browse/DSS-327">DSS-327</a>. 
                    </p>
                    <p>
Since SignServer >=3.2.1 it is possible to supply extra request data called RequestMetadata containing key/value pairs that can be used by the signers. For instance the PDFSigner uses this feature to let the client supply a PDF password. 
                    </p>
        </section>

		<section name="Java Client API">
                    <p>
Built along with the WebService is a Java API that can be used by clients. It's available in the file lib/SignServer-Client-SignServerWS.jar (the old SignServerWS interface) and lib/SignServer-Client-ClientWS.jar (the ClientWS interface). 
                    </p>
		</section>

		<section name="SigningAndValidation API">
			<p>
				The SigningAndValidation API is a wrapper around the previous
				mentioned API in order to have a simplified interface that also
				is the same regardless if WebService or EJB Remote calls are used.
			</p>
			<p>
				To use the API include the file lib/SignServer-Client-SigningAndValidationAPI.jar.
			</p>
			<subsection name="Sample Code">
                            <h4>Signing and validating an XML document</h4>
                                    <source>
try {
    System.setProperty("javax.net.ssl.trustStore", "p12/truststore.jks");
    System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
  
    ISigningAndValidation signserver = new SigningAndValidationWS("localhost", 8442, true);

    // Document to sign
    byte[] unsigned = "&lt;document&gt;&lt;name&gt;Some content&lt;/name&gt;&lt;/document&gt;".getBytes();
    byte[] signed;

    // Signing
    GenericSignResponse signResp = signserver.sign("DemoXMLSigner", unsigned);
    signed = signResp.getProcessedData();
    System.out.println("Signed: " + new String(signed));

    // Validating
    GenericValidationResponse validateResp = signserver.validate("DemoXMLValidator", signed);
    System.out.println("Valid: " + validateResp.isValid());

    if(validateResp.getSignerCertificate() != null) {
        if(validateResp.getSignerCertificate() instanceof X509Certificate) {
            X509Certificate signerCert = (X509Certificate) validateResp.getSignerCertificate();
            System.out.println("Signed by: " + signerCert.getSubjectDN().getName());
        }
    }
} catch (Exception ex) {
    ex.printStackTrace();
}                                   </source>

			</subsection>
		</section>

                <section name="Web Server Interface">
                    <subsection name="GenericProcessServlet">
                        <p>
				HTTP requests can be sent to the SignServer servlet GenericProcessServlet located at /signserver/process using
                                either POST or GET.
			</p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/process</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td><b>GET</b> or <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request content-type:</td><td><b>None</b>, <b>"x-www-form-urlencoded"</b>, <b>"multipart/form-data"</b> or <b>other<sup>*</sup></b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>workerName</b> - Name of the worker that should handle the request. Required unless workerId specified.</li>
                                        <li><b>workerId</b> - Id of the worker that should handle the request. Required unless workerName specified.</li>
                                        <li><b>data</b> - The bytes that should be signed or validated. Required for x-www-form-urlencoded.</li>
                                        <li><b>filerecievefile</b> - File upload used with multipart/form-data.</li>
                                        <li><b>pdfPassword</b> - Password for changing PDF. This can also be specified using the generic meta data parameters described below, using the key "pdfPassword". Optional and only used by PDFSigner.</li>
                                        <li><b>REQUEST_METADATA</b> - Meta data to pass on. Specified in Java properties file syntax. Optional.</li>
                                        <li><b>REQUEST_METADATA.x</b> - Sets a meta data parameter with the key specified by x. Overrides a value using the same key specified in the REQUEST_METADATA map. Optional.</li>
                                        <li><b>encoding</b> - Encoding of the data field. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the worker.</li>
                                        <li><b>processType</b> - The type of request. Can be any of "signDocument", "validateDocument",
                                        or "validateCertificate". Optional. If not specified, defaults to "signDocument".</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td>
                                <td>
                                    <ul>
                                        <li><b>HTTP 200</b> (OK): The request was successfull</li>
                                        <li><b>HTTP 400</b> (Bad Request): The request could not be fulfilled. Some request data were missing or incorrect etc.</li>
                                        <li><b>HTTP 401</b> (Unauthorized): The worker requires user authentication</li>
                                        <li><b>HTTP 404</b> (Not Found): The requested workerName or workerId does not represent an existing worker</li>
                                        <li><b>HTTP 413</b> (Request Entity Too Large): The data field or uploaded file is too large. See the HTTP_MAX_UPLOAD_SIZE global configuration property.</li>
                                        <li><b>HTTP 500</b> (Internal Server Error): There was an internal error when processing the request. Typically indicating a configuration problem or unexpected error at the server side.</li>
                                        <li><b>HTTP 503</b> (Service Unavailable): The worker is not active, its crypto token is not activated or similar</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td>Depending on the worker, text/plain for the validators.</td>
                            </tr>
                            <tr>
                                <td>Response content:</td>
                                <td>The signed document for signers.<br/>
                                A string starting with "VALID" or "INVALID" for document validators.
                                <sup>*</sup>Note to integrators: In future versions of SignServer there might be more information added after VALID/INVALID, such as a ;-separated list of additional information or more lines with information.<br/>
                                A ;-separated string containing
                                validation status code (see list below), valid purposes, status message, revocation reason (-1 if not revoked), and revocation date (empty when not revoked)
                                for certificate validators.
                                </td>
                            </tr>
                            <tr>
                                <td>Validation status codes:</td>
                                <td>
                                    <ul>
                                        <li><b>VALID</b> The certificate is valid</li>
                                        <li><b>REVOKED</b> The certificate has been revoked</li>
                                        <li><b>NOTYETVALID</b> The certificate is not yet valid</li>
                                        <li><b>EXPIRED</b> The certificate has expired</li>
                                        <li><b>DONTVERIFY</b> The certificate doesn't verify</li>
                                        <li><b>CAREVOKED</b> The CA certificate has been revoked</li>
                                        <li><b>CANOTYETVALID</b> The CA certificate is not yet valid</li>
                                        <li><b>CAEXPIRED</b> The CA certificate has expired</li>
                                        <li><b>BADCERTPURPOSE</b> The certificate has no valid certificate purpose</li>
                                        <li><b>ISSUERNOTSUPPORTED</b> The issuer of the certificate is not supported</li>
                                    </ul>
                                </td>
                            </tr>
                        </table>
                        <p>
                            <sup>*</sup> if the request content-type in a POST is specified as something else than "x-www-form-urlencoded" or
                            "multipart/form-data" the message body is not parsed but instead directly passed to the worker specified by workerName or workerId
                            in the URI's query string.
                        </p>

                        <h4>Configuration</h4>
                            <p><b>HTTP_MAX_UPLOAD_SIZE</b> = Global configuration property that can be set to specify the maximum size (in bytes) of the HTTP request (Defaut: 104857600).</p>
                        

                        <h4>Samples</h4>
                            <ul>
                                <li>
                                    HTTP GET:<br/>
                                    http://localhost:8080/signserver/process?workerName=DemoXMLSigner&amp;data=%3Croot%3Ehej2%3C/root%3E<br/>
                                    http://localhost:8080/signserver/process?workerName=DemoXMLSigner&amp;encoding=base64&amp;data=PGhlajI%2Bb2s8L2hlajI%2BCg%3D%3D<br/>
                                    <br/>
                                </li>
                                <li>
                                    HTTP POST with multipart/form-data or x-www-form-urlencoded:<br/>
                                    For example see /signserver/demo/xmlsign.jsp (multipart/form-data) and /signserver/demo/genericsign.jsp (x-www-form-urlencoded).<br/>
                                    <br/>
                                </li>
                                <li>
                                    HTTP POST with other content-type:<br/>
                                    See the TimeStampClient.<br/>
                                    <br/>
                                </li>
                                <li>
                                    Samples of content output for certificate validation:<br/>
                                    <ul>
                                        <li>VALID;;This certificate is valid;-1;</li>
                                        <li>ISSUERNOTSUPPORTED;;Issuer of given certificate isn't supported;-1;</li>
                                        <li>REVOKED;;This certificate is revoked;3;1376565200519</li>
                                    </ul>
                                </li>
                            </ul>
                        

                    </subsection>
                    <subsection name="WorkerServlet">
                        <p>
				HTTP requests can be sent to the SignServer servlet WorkerServlet located at /signserver/worker/* using
                                either POST or GET.<br/>
                Requests are forwarded to the GenericProcessServlet, except that the worker name is taken from the URL.<br/>
                            Worker name or ID given through request parameters are ignored.
			</p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/worker/*</b> (* denotes a worker name)</td>
                            </tr>
                            <tr>
                                <td>Method:</td><td><b>GET</b> or <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request content-type:</td><td><b>None</b>, <b>"x-www-form-urlencoded"</b>, <b>"multipart/form-data"</b> or <b>other<sup>*</sup></b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>data</b> - The bytes that should be signed or validated. Required for x-www-form-urlencoded.</li>
                                        <li><b>filerecievefile</b> - File upload used with multipart/form-data.</li>
                                        <li><b>pdfPassword</b> - Password for changing PDF. Optionally and only used by PDFSigner.</li>
                                        <li><b>encoding</b> - Encoding of the data field. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the worker.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td>
                                <td>
                                    <ul>
                                        <li><b>HTTP 200</b> (OK): The request was successfull</li>
                                        <li><b>HTTP 400</b> (Bad Request): The request could not be fulfilled. Some request data were missing or incorrect etc.</li>
                                        <li><b>HTTP 401</b> (Unauthorized): The worker requires user authentication</li>
                                        <li><b>HTTP 404</b> (Not Found): The requested workerName or workerId does not represent an existing worker</li>
                                        <li><b>HTTP 413</b> (Request Entity Too Large): The data field or uploaded file is too large</li> 
                                        <li><b>HTTP 500</b> (Internal Server Error): There was an internal error when processing the request. Typically indicating a configuration problem or unexpected error at the server side.</li>
                                        <li><b>HTTP 503</b> (Service Unavailable): The worker is not active, its crypto token is not activated or similar</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td>Depending on the worker</td>
                            </tr>
                        </table>

                        <h4>Samples</h4>
                            <ul>
                                <li>
                                    HTTP GET:<br/>
                                    http://localhost:8080/signserver/worker/DemoXMLSigner?data=%3Croot%3Ehej2%3C/root%3E<br/>
                                    http://localhost:8080/signserver/worker/DemoXMLSigner?encoding=base64&amp;data=PGhlajI%2Bb2s8L2hlajI%2BCg%3D%3D<br/>
                                    <br/>
                                </li>
                            </ul>
                        

                    </subsection>
                    <subsection name="SODProcessServlet">
                        <p>
                            Servlet recieving HTTP POST requests containing data group hashes
                            and creates a MRTDSODSignerRequest and passes it to the specified
                            MRTDSODSigner. The response from the servlet is the signed security
                            object in binary format.
                        </p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/sod</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td> <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>workerName</b> - Name of the worker that should handle the request. Required unless workerId specified.</li>
                                        <li><b>workerId</b> - Id of the worker that should handle the request. Required unless workerName specified.</li>
                                        <li><b>dataGroup1 to dataGroup16</b> - The data group hashes that should be put in the SO(d). At least one required.</li>
                                        <li><b>encoding</b> - Encoding of the data group hash fields. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the MRTDSODSigner.</li>
                                        <li><b>ldsVersion</b> - Request a specific LDS version: "0107" for V1.7 or "0108" for V1.8. Optional. If not specified the version from the configuration is used. If version is V1.8 unicodeVersion also needs to be specified.</li>
                                        <li><b>unicodeVersion</b> - Unicode version to store in the SOd. Optional. Only supported if ldsVersion "0108" specified. Specify "040000" for Unicode version 4.0.0.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td><td>The same response codes as for the GenericProcessServlet are used.</td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td><b>application/octet-stream</b></td>
                            </tr>
                        </table>


                        <h4>Samples</h4>
                            <ul>
                                <li>
                                    See /signserver/demo/mrtdsodsign.jsp.<br/>
                                    <br/>
                                </li>
                            </ul>
                        
                    </subsection>
                    <subsection name="SODProcessWorkerServlet">
                        <p>
                            Servlet recieving HTTP POST requests containing data group hashes
                            and creates a MRTDSODSignerRequest and passes it to the specified
                            MRTDSODSigner. The response from the servlet is the signed security
                            object in binary format.<br/>
                            Requests are forwarded to the SODProcessServlet, except that the worker name is taken from the URL.<br/>
                            Worker name or ID given through request parameters are ignored.
                        </p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/sodworker</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td> <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>dataGroup1 to dataGroup16</b> - The data group hashes that should be put in the SO(d). At least one required.</li>
                                        <li><b>encoding</b> - Encoding of the data group hash fields. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the MRTDSODSigner.</li>
                                        <li><b>ldsVersion</b> - Request a specific LDS version: "0107" for V1.7 or "0108" for V1.8. Optional. If not specified the version from the configuration is used. If version is V1.8 unicodeVersion also needs to be specified.</li>
                                        <li><b>unicodeVersion</b> - Unicode version to store in the SOd. Optional. Only supported if ldsVersion "0108" specified. Specify "040000" for Unicode version 4.0.0.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td><td>The same response codes as for the GenericProcessServlet are used.</td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td><b>application/octet-stream</b></td>
                            </tr>
                        </table>


                        <h4>Samples</h4>
                        <ul>
                            <li>
                                See /signserver/demo/mrtdsodsign.jsp.<br/>
                                <br/>
                            </li>
                        </ul>
                    </subsection>
		</section>

                <section name="Client Command Line Interface (CLI)" id="clientcli">
                    <p>
Requests can be sent to the workers using the Client CLI. After building
SignServer the script bin/client.sh can be run.
                    </p>
                    <source>
$ bin/signclient
usage: signclient &lt;signdocument | validatedocument | timestamp | validatecertificate | signdatagroups&gt;</source>

                    <subsection name="signdocument">
                        <p>
Request signing of a document using HTTP(s) or web services. 
                        </p>
                        <source>
usage: signdocument &lt;-workername WORKERNAME | -workerid WORKERID&gt;
                    [options]
Request a document to be signed by SignServer
 -data             Data to send to the worker.
 -host             Server name or IP address. Default: localhost
 -indir            Directory to read input files from. Required if
                   outdir specified. Can not be combined with infile
                   or outfile.
 -infile           File to read data to send to the worker from.
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for
                   client certificate authentication.
 -keystorepwd      Password for reading the keystore.  If keystore is
                   specified but not this keystore password option,
                   the CLI will instead prompt for the password.
 -metadata         Additional meta data to send to the signer. The
                   parameters should be given in the form KEY=VALUE.
                   This option can be given multiple times.
 -onefirst         In batch mode, don't send all requests until the
                   first succeeds. This is primary to prevent too many
                   incorrect password attempts. Default if username
                   is provided and -startall not provided.
 -outdir           Directory to write output files to. Required if
                   indir specified. Can not be combined with infile
                   or outfile.
 -outfile          File to write the result to. If not specified the
                   result is written to stdout.
 -password         Password for authentication. If username is
                   specified but not this password option, the CLI
                   will instead prompt for the password.
 -pdfpassword      Password for changing the PDF (if required).
 -port             Server port. Default: 8080 (for HTTP), 8442 for
                   HTTPS and 8443 for HTTPS with client
                   authentication.
 -protocol         Method of interacting with SignServer. HTTP,
                   CLIENTWS or WEBSERVICES. Default: HTTP.
 -removefromindir  Specify this flag to have the successfully
                   processed input files removed from indir.
 -servlet          Servlet to call. Default /signserver/process
 -startall         In batch mode, send all requests at once, without
                   waiting for the first to succeed. Default unless
                   username is provided or -onefirst provided.
 -threads          Number of threads for sending the requests. Only
                   allowed in batch mode, i.e. when indir and outdir
                   are specified. Default: 1.
 -truststore       Keystore with trusted certificates to use with
                   HTTPS.
 -truststorepwd    Password for the keystore with trusted
                   certificates. If truststore is specified but not
                   this truststore password option, the CLI will
                   instead prompt for the password.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) signdocument -workername XMLSigner -data "&lt;root/&gt;"
b) signdocument -workername XMLSigner -infile /tmp/document.xml
c) signdocument -workerid 2 -data "&lt;root/&gt;" -truststore truststore.jks
-truststorepwd changeit
d) signdocument -workerid 2 -data "&lt;root/&gt;" -keystore superadmin.jks
-truststorepwd foo123
e) signdocument -workerid 2 -data "&lt;root/&gt;" -metadata param1=value1
-metadata param2=value2
f) signdocument -workerid 3 -indir ./input/ -removefromindir -outdir
./output/ -threads 5</source>
                    </subsection>

                    <subsection name="validatedocument">
                        <p>
Request a document to be validated.
                        </p>
                        <source>
usage: validatedocument &lt;-workername WORKERNAME | -workerid WORKERID&gt;
                        [options]
Request a document to be validated by SignServer
 -data             Data to send to the worker.
 -host             Server name or IP address. Default: localhost
 -infile           File to read data to send to the worker from.
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for
                   client certificate authentication.
 -keystorepwd      Password for reading the keystore.  If keystore is
                   specified but not this keystore password option,
                   the CLI will instead prompt for the password.
 -metadata         Additional meta data to send to the signer. The
                   parameters should be given in the form KEY=VALUE.
                   This option can be given multiple times.
 -password         Password for authentication.
 -port             Server port. Default: 8080 (for HTTP), 8442 for
                   HTTPS and 8443 for HTTPS with client
                   authentication.
 -protocol         Method of interaction with SignServer.
                   WEBSERVICES, or HTTP. Default: WEBSERVICES.
 -servlet          URL to the webservice servlet. Default:
                   /signserver/signserverws/signserverws?wsdl
 -truststore       Keystore with trusted certificates to use with
                   HTTPS.
 -truststorepwd    Password for the keystore with trusted
                   certificates. If truststore is specified but not
                   this truststore password option, the CLI will
                   instead prompt for the password.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) validatedocument -workername XMLValidator -data "&lt;root&gt;&lt;Signature...
b) validatedocument -workername XMLValidator -infile /tmp/signed.xml
c) validatedocument -workerid 2 -infile /tmp/signed.xml -truststore
truststore.jks -truststorepwd changeit
d) validatedocument -workerid 2 -infile /tmp/signed.xml -keystore
superadmin.jks -truststorepwd foo123
e) validatedocument -workername XMLValidator -protocol HTTP -infile
/tmp/signed.xml
f) validatedocument -workername XMLValidator -infile /tmp/signed.xml -metadata param1=value1 -metadata param2=value2</source>
                    </subsection>

                    <subsection name="timestamp">
                        <source>
$ bin/signclient timestamp
usage: timestamp &lt;options&gt; [url]
 -base64                Give this option if the stored request/reply
                        should be base64 encoded, default is not.
 -certreq               Request signer certificate
 -help                  Print this message.
 -infile &lt;file&gt;         File containing message to time stamp.
 -inrep &lt;file&gt;          Input file containing an earlier stored base64
                        encoded response, to verify.You must specify the
                        verify flag also.
 -inreq &lt;file&gt;          Input file containing an earlier stored request to
                        use instead of creating a new. You must specify
                        the request flag also.
 -instr &lt;string&gt;        String to be time stamped, if neither instr or
                        infile is given, the client works in test-mode
                        generating it's own message.
 -keyalias &lt;arg&gt;        Alias of the key in the keystore to use for
                        authentication.
 -keystore &lt;arg&gt;        Keystore with private key and certificate for
                        client certificate authentication.
 -keystorepwd &lt;arg&gt;     Password for reading the keystore.  If keystore is
                        specified but not this keystore password option,
                        the CLI will instead prompt for the password.
 -outrep &lt;file&gt;         Output file to store the recevied TSA reply, if
                        not given the reply is not stored.
 -outreq &lt;file&gt;         Output file to store the sent TSA request, if not
                        given the request is not stored.
 -print                 Prints content of a request, response and/or token
 -reqpolicy &lt;oid&gt;       Request timestamp issued under a policy OID
 -signerfile &lt;file&gt;     Input file containing the PEM encoded certificate
                        of the TSA signer.Used to verify a stored
                        response.
 -sleep &lt;num&gt;           Sleep a number of milliseconds after each request.
                        Default 1000 ms.
 -truststore &lt;arg&gt;      Keystore with trusted certificates to use with
                        HTTPS.
 -truststorepwd &lt;arg&gt;   Password for the keystore with trusted
                        certificates. If truststore is specified but not
                        this truststore password option, the CLI will
                        instead prompt for the password.
 -url &lt;url&gt;             Url of TSA, e.g.
                        http://127.0.0.1:8080/signserver/process?workerId=
                        1.
 -verify                Give this option if verification of a stored reply
                        should be done, work together with inrep and
                        cafile. If given, no request to the TSA will
                        happen.

Sample usages:
a) timestamp -url http://localhost:8080/signserver/tsa?workerName=TimeStampSigner
b) timestamp -print -inreq query.tsq
c) timestamp -print -inrep reply.tsr</source>
                    </subsection>

                    <subsection name="validatecertificate">
                        <p>
Request a certificate to be validated by the specified service.
                        </p>
                        <source>
usage: Usage: java -jar validate.jar &lt;options&gt;

 -cert &lt;cert-file&gt;              Path to certificate file (DER or PEM)
                                (Required).
 -certpurposes &lt;certpurposes&gt;   A ',' separated string containing
                                requested certificate purposes.
 -der                           Certificate is in DER format.
 -help                          Display this info
 -hosts &lt;hosts&gt;           A ',' separated string containing the
                                hostnames of the validation service nodes.
                                Ex 'host1.someorg.org,host2.someorg.org'.
                                When using the HTTP protocol, only one
                                host name can be specified. (Required).
 -pem                           Certificate is in PEM format (Default).
 -port &lt;port&gt;                   Remote port of service (Default is 8080 or
                                8442 for SSL).
 -protocol &lt;protocol&gt;           Protocol to use, either WEBSERVICES or
                                HTTP. Default: WEBSERVICES.
 -service &lt;service-name&gt;        The name or ID of the validation service
                                to process request. (Required)
 -silent                        Don't produce any output, only return
                                value.
 -truststore &lt;jks-file&gt;         Path to JKS truststore containing trusted
                                CA for SSL Server certificates.
 -truststorepwd &lt;password&gt;      Password to unlock the truststore.

The following values is returned by the program that can be used when scripting.
  -2   : Error happened during execution
  -1   : Bad arguments
   0   : Certificate is valid
   1   : Certificate is revoked
   2   : Certificate is not yet valid
   3   : Certificate have expired
   4   : Certificate doesn't verify
   5   : CA Certificate have been revoked
   6   : CA Certificate is not yet valid
   7   : CA Certificate have expired
   8   : Certificate have no valid certificate purpose

Sample usages:
a) validatecertificate -service CertValidationWorker -hosts localhost -cert
    certificate.pem
b) validatecertificate -service 5806 -hosts localhost -cert certificate.pem
    -truststore p12/truststore.jks -truststorepwd changeit
c) validatecertificate -service CertValidationWorker -hosts localhost
    -cert certificate.pem -protocol HTTP</source>
                    </subsection>

                    <subsection name="signdatagroups">
                        <p>
Sign the specified data groups and produce an SOd (MRTD).
                        </p>
                        <source>
$ bin/client.sh signdatagroups
usage: signdatagroups &lt;options&gt;
Request MRTD data groups to be signed
 -data &lt;arg&gt;            Data to send to the worker.
 -encoding &lt;arg&gt;        Encoding of the data option. None or base64.
                        Default: none.
 -host &lt;arg&gt;            Server name or IP address. Default: localhost
 -keyalias &lt;arg&gt;        Alias of the key in the keystore to use for
                        authentication.
 -keystore &lt;arg&gt;        Keystore with private key and certificate for
                        client certificate authentication.
 -keystorepwd &lt;arg&gt;     Password for reading the keystore.  If keystore is
                        specified but not this keystore password option,
                        the CLI will instead prompt for the password.
 -metadata &lt;arg&gt;        Additional meta data to send to the signer. The
                              parameters should be given in the form KEY=VALUE.
                              This option can be given multiple times.
 -password &lt;arg&gt;        Password for authentication. If username is
                        specified but not this password option, the CLI
                        will instead prompt for the password.
 -port &lt;arg&gt;            Server port. Default: 8080 (for HTTP), 8442 for
                        HTTPS and 8443 for HTTPS with client
                        authentication.
 -protocol &lt;arg&gt;        Method of interacting with SignServer. HTTP or
                        CLIENTWS. Default: HTTP.
 -repeat &lt;arg&gt;          Run the operation this number of times. Default: 1
 -servlet &lt;arg&gt;         Servlet to call. Default /signserver/sod
 -truststore &lt;arg&gt;      Keystore with trusted certificates to use with
                        HTTPS.
 -truststorepwd &lt;arg&gt;   Password for the keystore with trusted
                        certificates. If truststore is specified but not
                        this truststore password option, the CLI will
                        instead prompt for the password.
 -username &lt;arg&gt;        Username for authentication.
 -workerid &lt;arg&gt;        ID of worker which should perform the operation.
 -workername &lt;arg&gt;      Name of worker which should perform the operation.

Sample usages:
a) signdatagroups -workername MRTDSODSigner -data "1=value1&amp;2=value2&amp;3=value3"
b) signdatagroups -workername MRTDSODSigner -data "1=value1&amp;2=value2&amp;3=value3" -metadata param1=value1 -metadata param2=value2</source>
                    </subsection>

                </section>

                <section name="Administration Web Service" id="adminws">
                    <p>
The SignServer AdminWS can be used for remote administration of SignServer
over client authenticated HTTPS. Access is granted based on a list of
certificate serial number and issuer distinguished name pairs. Currently there
is only one access level and all administrators granted access will be able to
perform all operations.
                    </p>
                    <p>
The WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/AdminWSService/AdminWS?wsdl
                    </p>
                    <p>
Authorizing administrators can be done using the Admin CLI command "wsadmins".
                    </p>
                    <source>
Usage: signserver wsadmins -add -certserialno &lt;certificate serial number (in hex)&gt; -issuerdn &lt;issuer DN&gt;
Usage: signserver wsadmins -add -cert &lt;PEM or DER file&gt;
Usage: signserver wsadmins -remove -certserialno &lt;certificate serial number (in hex)&gt; -issuerdn &lt;issuer DN&gt;
Usage: signserver wsadmins -list
Example 1: signserver wsadmins -add -certserialno 123abcdef -issuerdn "C=SE, CN=Neo Morpheus"
Example 2: signserver wsadmins -add -cert cert.pem
Example 3: signserver wsadmins -remove -certserialno 123abcdef -issuerdn "C=SE, CN=Neo Morpheus"
Example 4: signserver wsadmins -list</source>
                    <p>
Notice that the certificate serial number should be entered as the hexadecimal
representation (leading zeros and upper/lowercase is not significant). 
Also notice that the issuer DN currently should be entered in the reversed order 
and with spaces after each component. In the example above the issuer DN from the 
certificate actually is "CN=Neo Morpheus, C=SE". 
                    </p>
                    <p>
An administrator can also be added by supplying a client certificate as an argument.
The serial number and issuer DN is then taken from that certificate.
                    </p>
                    <p>
To troubleshoot an "Administrator not authorized to resource" see the logs for how 
SignServer interprets the serialnumber and subject DN. Example:
                    </p>
                    <pre>
19:00:33,946 INFO  [AdminWS] ADMIN OPERATION; subjectDN=C=SE, O=Markus Organization, OU=Internal Testing 1, CN=External RA Admin 1; serialNumber=4a3442e98e3ce428; issuerDN=C=SE, O=Markus Organization, OU=Internal Testing 1, CN=MarkusAdminCA1; authorized=false; operation=getWorkers; arguments=
                    </pre>
                </section>
                
                <section name="Apache HTTP Server as proxy">
                    <p>
This section will show you examples on how the Apache Web Server (version 2.2.20) can be used as a proxy in front of SignServer. This guide is only informative, you should also always consult the current Apache documentation for the modules used. The proxy could be used for multiple reasons including:
                    </p>
                    <ul>
                        <li>Use standard ports (80, 443) instead of unprivileged ports used by the application server</li>
                        <li>Making workers accessible through more nice looking URLs.<br/>For example "http://tsa.example.com" instead of "http://example.com:8080/signserver/tsa?workerName=TimeStampSigner1"</li>
                        <li>Use any of the access control and authentication mechanism available in Apache</li>
                        <li>Redirect HTTP traffic to HTTPS</li>
                        <li>Only accepting requests to specified locations</li>
                    </ul>
                    <p>
As the requests should go through the proxy you will probably want to configure the application server to only listen to localhost and/or use a firewall blocking the application server ports from external requests. To configure JBoss to only listen to localhost set the following properties in signserver_deploy.properties:
                    </p>
                    <source>
httpsserver.bindaddress.pubhttp=127.0.0.1
httpsserver.bindaddress.pubhttps=127.0.0.1
httpsserver.bindaddress.privhttps=127.0.0.1</source>
                    <p>
Install the Apache web server and enable required modules (the following commands are for Ubuntu but should be similar in other distributions as well):
                    </p>
                <source>
$ sudo apt-get install apache2
$ cd /etc/apache2/mods-enabled/
$ sudo ln -s ../mods-available/proxy.load proxy.load
$ sudo ln -s ../mods-available/proxy_http.load proxy_http.load
$ sudo ln -s ../mods-available/proxy_ajp.load proxy_ajp.load
$ sudo ln -s ../mods-available/proxy_balancer.load proxy_balancer.load
$ sudo ln -s ../mods-available/rewrite.load rewrite.load
$ sudo ln -s ../mods-available/ssl.load ssl.load</source>
    
   
                <subsection name="Example: Rewrite URLs for TSA (using mod_proxy and mod_rewrite)">
                    <p>
A sample configuration how to fix up nice URLs for time-stamping so that you can point your TSA clients to http://tsa.example.com/ instead of http://tsa.example.com:8080/signserver/process?workerName=TimeStampSigner1.
                    <br/>
This configuration combines mod_proxy with mod_rewrite to be able to set the workerName or workerId, so you can have different TSAs available on different URLs.
                    </p>
                    <source>
&lt;VirtualHost tsa.example.com:80>
    ServerName tsa.example.com
    ServerAlias tsa.example.com
    CustomLog /var/log/apache2/access.log combined

    RewriteEngine on
    RewriteLogLevel 5
    RewriteLog "/var/log/apache2/rewrite.log
    RewriteRule ^/$ /?workerName=TimeStampSigner1 [PT]

    ProxyRequests Off
    &lt;Proxy *&gt;
        Order deny,allow
        Allow from all
    &lt;/Proxy&gt;
    ProxyPass / http://127.0.0.1:8080/signserver/process
    ProxyPassReverse / http://127.0.0.1:8080/signserver/process
&lt;/VirtualHost></source>
                </subsection>
                
                <subsection name="Example: Rewrite URLs and redirect to HTTPS (using AJP)">
                    <p>
The following example configures three virtual hosts. The first signserver.example.com:80 just redirects all requests to use HTTPS and thus the virtual host signserver.example.com:443. The second virtual host is configured to proxy requests to the /signserver path on the application server using the AJP protocol. It is also configured to use HTTPS with a server certificate. The last virtual hosts auth.signserver.example.com using an additonal IP address is configured to require client certificate authentication. 
                    </p>
                    <p>
Notice: Some application servers (i.e. JBoss 4) might have problems writing the correct port number in the endpoint URL in the web services WSDL file when using a proxy (i.e. writing 8443 instead of 443).
                    </p>
                    <source><![CDATA[
<VirtualHost signserver.example.com:80>
    ServerName signserver.example.com
    ServerAlias signserver.example.com

    RewriteEngine On
    RewriteCond %{HTTPS} off
    RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}

    # Configure log
    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined

</VirtualHost>

<VirtualHost signserver.example.com:443>
    ServerName signserver.example.com
    ServerAlias signserver.example.com

    ProxyRequests Off
    <Proxy balancer://mycluster-3>
        BalancerMember ajp://localhost:8009/signserver
    </Proxy>
    ProxyPass / balancer://mycluster-3/

    RewriteEngine   On

    # Treat requests to / and /signserver/ as the same for web services endpoints to work.
    RewriteCond     %{THE_REQUEST}  /signserver/
    RewriteRule     ^/signserver/(.*)$ /$1 [PT]

    # Configure secure SSL for this server using SSL certificate generated by EJBCA
    SSLEngine on
    SSLCipherSuite HIGH
    SSLProtocol all -SSLv2
    SSLCertificateFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/signserver.example.com-cert.pem
    SSLCertificateKeyFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/signserver.example.com-key.pem

    # Configure log
    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined
</VirtualHost>

# Note: auth.signserver.example.com must have a different IP address
<VirtualHost auth.signserver.example.com:443>
    ServerName auth.signserver.example.com
    ServerAlias auth.signserver.example.com

    ProxyRequests Off
    <Proxy balancer://mycluster-4>
        BalancerMember ajp://localhost:8009/signserver
    </Proxy>
    ProxyPass / balancer://mycluster-4/

    RewriteEngine   On
    # Treat requests to / and /signserver/ as the same for web services endpoints to work.
    RewriteCond     %{THE_REQUEST}  /signserver/
    RewriteRule     ^/signserver/(.*)$ /$1 [PT]

    # Configure secure SSL for this server using SSL certificate generated by EJBCA
    SSLEngine on
    SSLCipherSuite HIGH
    SSLProtocol all -SSLv2
    SSLCertificateFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/auth.signserver.example.com-cert.pem
    SSLCertificateKeyFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/auth.signserver.example.com-key.pem

    SSLVerifyClient require
    SSLVerifyDepth 1
    SSLCACertificateFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/truststore.pem

    # Configure log
    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined
</VirtualHost>]]></source>
                </subsection>
                
                <subsection name="Example: Granting access to specific workers only">
                    <p>
This example shows how it is possible to limit access to only specified resources. 
                    </p>
                    <p>
If you are going to grant different users access to different workers always remember to first deny access from the root location. The reason is that there are other ways to access a worker than the "/worker/*" or "/sodworker/*" pattern. For instance /process, /tsa, /pdf and /sod etc as well as using the web services interfaces /signserverws, /SignServerWSService, /validationws, /ValidationWSService and /ClientWSService all can be used to invoke <b>any</b> worker.
                    </p>
                    <p>
If you instead relay on SignServer to do the authentication/authorization it could still be good from a security point to only grant access to the locations you intend to use. In that case you would probably want to also give access to the  web services interfaces, /worker and /process etc.
                    </p>
                    <p>
Also remember if you are proxying from multiple virtual hosts (i.e. if you have one with and one without client authentication as in the example above) that you might want to add the access restrictions to all of them.
                    </p>
                    <source><![CDATA[
    ...
    # First, deny access globally and then only give access to resources explicitly
    <Location />
    	Order Deny,Allow
    	Deny from all
    </Location>

    # Allow index page
    <LocationMatch "^/$">
	Order Allow,Deny
	Allow from all
    </LocationMatch>

    # Allow demo web pages
    <Location /demo/>
	Order Allow,Deny
	Allow from all
    </Location>

    # Allow documentation
    <Location /doc/>
	Order Allow,Deny
	Allow from all
    </Location>

    # Allow web page resources
    <LocationMatch "\.(css|js|jpg|png)$">
	Order Allow,Deny
	Allow from all
    </LocationMatch>
    
    # Allow the Admin interface
    <Location /AdminWSService/>
	Order Allow,Deny
	Allow from all
    </Location>

    # Grant everybody access to the XMLSigner
    <Location /worker/XMLSigner>
	Order Allow,Deny
	Allow from all
    </Location>
                        
    # Grant everybody access to the MRTDSODSigner
    <Location /sodworker/MRTDSODSigner>
        Order Allow,Deny
        Allow from all
    </Location>

    # Grant valid users access to the CMSSigner
    <Location /worker/CMSSigner>
	Order Allow,Deny
        Allow from all
        AuthType Basic
        AuthName "Restricted CMSSigner access"
    	AuthUserFile /home/markus/.htpasswd
    	Require valid-user
    </Location>
    ...]]></source>
                </subsection>
                
            </section>

    </body>
</document>

